---
title: "第 6 章：Server Actions：现代 SAAS 的后端“突变” (Mutation)"
description: "从 Django 或 Flask 迁移过来，我们最习惯的模式是什么？为 'Create', 'Update', 'Delete' (C/U/D) 操作定义 REST/GraphQL API 路由。"
date: "2026-01-06"
published: true
categories: ["typescript", "python", "react"]
author: "notion-import"
image: "/images/blog/post-1.png"
---


# 第 6 章：Server Actions：现代 SAAS 的后端“突变” (Mutation)

从 Django 或 Flask 迁移过来，我们最习惯的模式是什么？为 "Create", "Update", "Delete" (C/U/D) 操作定义 REST/GraphQL API 路由。

例如，在 Flask 中，我们可能会这样写：

```python
# 传统的 Flask API 端点
@app.route('/api/project', methods=['POST'])
@jwt_required()
def create_project():
    data = request.get_json()
    # ... 使用 Pydantic 验证数据 ...
    user_id = get_jwt_identity()
    # ... 数据库操作 ...
    return jsonify({"message": "Project created"}), 201
```

然后在 React 前端，我们会使用 `fetch` 或 `axios` 来调用这个端点：

```typescript
// 传统的客户端 fetch
const handleSubmit = async (data) => {
  const response = await fetch('/api/project', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
    body: JSON.stringify(data),
  });
  // ... 处理响应和 UI 状态 ...
};
```

这套 "Client-Server" 模式清晰、解耦，但也很繁琐。你需要管理 API 路由、HTTP 方法、序列化、反序列化、CORS、身份验证头。

Next.js 14+ 带来的 Server Actions 彻底改变了这一点。它允许你将后端逻辑（突变）直接定义并从客户端组件中调用，而无需手动创建和管理 API 路由。这是一种内置的、更安全的 RPC (远程过程调用) 范式。

## 6.1. 什么是 Server Actions (vs. Django/Flask API)

Server Action 本质上是一个在服务器端安全执行的异步函数，你可以通过在函数顶部添加 `"use server";` 指令来标记它。

它可以被定义在两个地方：

1. **组件内部（"Inlined"）**：直接定义在 `"use client"` 客户端组件中，通常用于简单的、与该组件紧密绑定的操作。
2. **单独文件（"Server Module"）**：定义在 `.ts` 文件中（例如我们项目中的 `src/actions/` 目录），并标记整个文件顶部为 `"use server";`。这是 **SAAS 项目的最佳实践**，因为它保持了逻辑的清晰分离和可重用性。

**思维转变：从 API 到函数调用**

| 传统 Python (Flask/Django)                                   | Next.js (Server Actions)                                       |
| ---------------------------------------------------------- | -------------------------------------------------------------- |
| 1. 在 `views.py` 或 `routes.py` 中定义一个 API 端点 (`@app.route`)。 | 1. 在 `src/actions/my-action.ts` 中定义一个 `async function`。        |
| 2. 在函数中，从 `request.json` 或 `request.form` 中解析数据。           | 2. 函数直接接收 `formData` (用于 `<form>`) 或普通参数。                      |
| 3. 使用 Pydantic 或 DRF Serializer 验证数据。                      | 3. 使用 Zod 验证数据（见 6.2）。                                         |
| 4. 在前端，使用 `fetch` 发起 `POST` 请求到 `/api/my-endpoint`。        | 4. 在前端，`import { myAction }` 并**直接调用** `await myAction(data)`。 |
| 5. Next.js 自动处理 `fetch` 封装、序列化和服务器调用。                      | 5. 对开发者而言，这就像调用一个本地的异步函数。                                      |

这种方式极大地简化了 C/U/D (Create, Update, Delete) 操作。Next.js 抽象掉了 HTTP 层的复杂性，让你能更专注于业务逻辑。

## 6.2. 最佳实践：next-safe-action 与 Zod 验证

虽然 Server Actions 很强大，但它们的原始形态（raw actions）在错误处理和输入验证方面非常粗糙。你需要手动管理 `try...catch`，而且返回给客户端的数据没有统一的结构。

这就好比在 Flask 视图中不使用 Pydantic 或 WTForms，而是手动处理 `request.form` 字典——这在企业级 SAAS 中是不可接受的。

**进入** **`next-safe-action`****。**

`next-safe-action` 是一个轻量级库，它为 Server Actions 提供了：

1. **Zod 验证**：无缝集成 Zod（我们在第 2 章中讨论过，它是 JS/TS 世界的 Pydantic）。
2. **类型安全的返回值**：返回一个统一的对象，如 `{ data, validationError, serverError }`。
3. **优雅的错误处理**：自动捕获 Zod 验证错误和服务器运行时错误。
4. **乐观更新 (Optimistic UI)**：易于集成的 `useAction` 钩子，用于处理加载状态和乐观更新。

**实战代码结构 (概念)：**

想象一下我们实战项目中的 `src/actions/project.ts`：

```typescript
// src/actions/project.ts
"use server";

import { z } from "zod";
import { createSafeActionClient } from "next-safe-action";
import { db } from "@/db"; // 我们的 Drizzle 实例
import { auth } from "@/auth"; // 我们的 Better Auth 实例

// 1. 定义 Zod schema (我们的 "Pydantic" / "DRF Serializer")
export const createProjectSchema = z.object({
  name: z.string().min(3, "项目名称至少需要 3 个字符"),
});

// 2. 创建一个 "safe action" 客户端
// 我们可以注入上下文，比如检查用户是否已认证
const action = createSafeActionClient({
  async middleware() {
    const session = await auth(); // 检查认证
    if (!session?.user?.id) {
      throw new Error("未授权：请先登录");
    }
    return { userId: session.user.id };
  },
});

// 3. 定义我们的 Action
export const createProject = action(
  createProjectSchema, // 传入 schema 进行验证
  async ({ name }, { userId }) => { // 接收经过验证的 "name" 和中间件返回的 "userId"

    // 4. 执行业务逻辑 (Drizzle DB 操作)
    try {
      const newProject = await db.insert(projectsTable).values({
        name,
        ownerId: userId,
      }).returning();

      return { success: true, project: newProject[0] };

    } catch (error) {
      console.error(error);
      return { serverError: "创建项目失败，请稍后重试。" };
    }
  }
);
```

**在客户端组件中调用：**

```typescript
// src/components/create-project-form.tsx
"use client";

import { useAction } from "next-safe-action/hook";
import { createProject, createProjectSchema } from "@/actions/project";

export function CreateProjectForm() {
  // 5. 使用 useAction 钩子
  const { execute, result, validationErrors, serverError, status } =
    useAction(createProject);

  const onSubmit = (data: z.infer<typeof createProjectSchema>) => {
    execute(data); // 直接执行
  };

  // ... 表单 (可以使用 react-hook-form) ...

  {/* 6. 优雅地处理状态 */}
  {status === "executing" && <p>正在创建...</p>}
  {serverError && <p className="text-red-500">{serverError}</p>}
  {validationErrors?.name && <p>{validationErrors.name[0]}</p>}
  {result?.data?.success && <p>项目 "{result.data.project.name}" 创建成功!</p>}
}
```

这种模式兼具了 Python 后端的健壮性（Pydantic 验证）和全栈框架的便利性。

## 6.3. [Skill 实战]：Server Action 执行后的服务器端重定向

这是一个 SAAS 应用中最常见的场景：用户提交表单（例如创建新项目），成功后，你需要将他们导航到新项目的详情页。

在 Flask/Django 中，我们会在视图函数末尾 `return redirect(url_for('project_detail', id=...))`。

在 Server Action 中，我们使用从 `next/navigation` 导入的 `redirect` 函数。这是一个服务器端 API，它会向浏览器发送 HTTP 30x 重定向指令。

**实战 Skill：****`nextjs-server-navigation/SKILL.md`** **的核心**

这个 Skill 的关键点在于理解 `redirect()` 是如何在 Server Action 中工作的。

```typescript
// src/actions/project.ts (续)
"use server";

import { redirect } from "next/navigation"; // 导入服务器端 redirect
import { revalidatePath } from "next/cache"; // 导入缓存刷新工具
// ... 其他 imports ...

export const createProject = action(
  createProjectSchema,
  async ({ name }, { userId }) => {

    let newProjectId: string;

    try {
      const newProject = await db.insert(projectsTable).values({
        name,
        ownerId: userId,
      }).returning({ id: projectsTable.id });

      newProjectId = newProject[0].id;

    } catch (error) {
      return { serverError: "创建项目失败" };
    }

    // 成功创建后

    // 1. [重要] 刷新缓存
    // 告诉 Next.js '/dashboard' 页面的数据已经过时了，下次访问时需要重新获取
    revalidatePath("/dashboard");

    // 2. [重要] 执行服务器端重定向
    // 这必须在 try...catch 块之外调用，因为它会抛出一个特殊的异常
    redirect(`/project/${newProjectId}`);

    // 注意：redirect() 之后的代码不会被执行
  }
);
```

**关键点：**

1. **`redirect()`** **(from** **`next/navigation`****)**：只能在 Server Components 或 Server Actions 中使用。它会终止当前函数的执行并发起重定向。
2. **`revalidatePath()`**：这是 Next.js 数据缓存（第 5 章）的核心。在执行“突变”后，我们必须手动“使缓存失效”，否则用户被重定向回列表页时，看到的可能还是旧数据。
3. **`useRouter`** **vs** **`redirect`**：客户端组件使用 `useRouter().push('/path')` 进行导航。Server Actions 使用 `redirect('/path')`。`redirect` 更强大，因为它是在服务器上发生的。

## 6.4. [代码解析]：分析实战项目中的 `src/actions/` 目录

理论讲完了，让我们深入实战项目的 `src/actions/` 目录。这个目录是我们 SAAS 应用的 "大脑"，它取代了传统 Python 后端中庞大的 `api/` 路由集合。

打开这个目录，你不会看到路由定义，而是会看到**按功能域 (domain)** 划分的 TS 文件，每个文件的顶部都标有 `"use server";`。

我们的 SAAS 模板项目结构可能如下：

```plain text
src/actions/
├── auth.actions.ts       # 处理登录、注册、退出 (与 Better Auth 交互)
├── payment.actions.ts    # 处理 Stripe 支付、创建 checkout会话
├── credits.actions.ts    # 处理用户 AI 点数 (credits) 的增减
├── project.actions.ts    # (如上例) 处理项目的 C/U/D
└── user.actions.ts       # 处理用户配置文件的更新、API Key 生成
└── index.ts              # (可选) 导出所有 actions，方便管理
```

**分析** **`payment.actions.ts`** **(概念)：**

让我们推演一下 `payment.actions.ts` 的内容，它连接了 Stripe (支付) 和 Drizzle (数据库)。

```typescript
// src/actions/payment.actions.ts
"use server";

import { z } from "zod";
import { createSafeActionClient } from "next-safe-action";
import { db } from "@/db";
import { auth } from "@/auth";
import { stripe } from "@/payment/stripe-server"; // 我们的 Stripe 服务器端实例
import { usersTable } from "@/db/schema";
import { eq } from "drizzle-orm";
import { absoluteUrl } from "@/lib/utils";

// 1. 定义 Schema
const createCheckoutSchema = z.object({
  planId: z.string(), // e.g., "pro_plan_monthly"
});

// 2. 定义 Action (同样需要认证)
const action = createSafeActionClient({ /* ...认证中间件... */ });

export const createCheckoutSession = action(
  createCheckoutSchema,
  async ({ planId }, { userId }) => {

    // 3. 从 Drizzle 获取用户信息 (比如 Stripe Customer ID)
    const user = await db.query.usersTable.findFirst({
      where: eq(usersTable.id, userId),
    });

    if (!user) return { serverError: "用户不存在" };

    const stripeCustomerId = user.stripeCustomerId || await createStripeCustomer(user);

    const returnUrl = absoluteUrl("/dashboard/billing");

    // 4. 调用 Stripe API 创建会话
    try {
      const session = await stripe.checkout.sessions.create({
        payment_method_types: ["card"],
        mode: "subscription",
        customer: stripeCustomerId,
        line_items: [{ price: process.env[planId], quantity: 1 }],
        success_url: returnUrl,
        cancel_url: returnUrl,
      });

      if (!session.url) {
        return { serverError: "无法创建支付会话" };
      }

      // 5. 返回 Stripe Checkout URL
      // 客户端收到这个 URL 后，会重定向到 Stripe 支付页面
      return { success: true, url: session.url };

    } catch (error)_ {
      console.error(error);
      return { serverError: "Stripe 通信失败" };
    }
  }
);
```

### 本章总结：思维的飞跃

通过本章的学习，我们完成了从 "API 端点" 到 "Server Action" 的核心思维转变。

对于 Python 开发者来说，`src/actions/` 目录就是你的 `views.py` / `api_views.py` 的集合，但它更强大：

1. **无需路由**：不再需要 `urls.py` 或 `@app.route`。
2. **类型安全**：`next-safe-action` + `Zod` 提供了比 DRF Serializer + Pydantic 更流畅的端到端类型安全。
3. **无缝集成**：可以直接在 Action 中调用数据库 (`Drizzle`)、认证 (`Better Auth`) 和第三方服务 (`Stripe`)。
4. **UI 协同**：Action 的设计（如 `useAction` 钩子）使其与 React 客户端组件的状态管理（`loading`, `error`）完美融合。

这不仅是代码量的减少，更是开发体验的巨大提升。我们现在拥有了类型安全、经过验证、与 UI 紧密结合的后端突变。

在接下来的部分，我们将深入探讨全栈架构的数据和状态层——Drizzle ORM 如何取代 SQLAlchemy，以及 Zustand 如何在客户端管理我们的全局状态。


