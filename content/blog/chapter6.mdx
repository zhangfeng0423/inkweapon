---
title: "Chapter 6: Server Actions - Modern SaaS Backend 'Mutations'"
description: "Migrating from Django or Flask, what pattern are we most used to? Defining REST/GraphQL API routes for 'Create', 'Update', 'Delete' (C/U/D) operations."
date: "2026-01-06"
published: true
categories: ["typescript", "python", "react"]
author: "notion-import"
image: "/images/blog/post-1.png"
---


# Chapter 6: Server Actions - Modern SaaS Backend "Mutations"

Migrating from Django or Flask, what pattern are we most used to? Defining REST/GraphQL API routes for "Create", "Update", "Delete" (C/U/D) operations.

For example, in Flask, we might write:

```python
# Traditional Flask API endpoint
@app.route('/api/project', methods=['POST'])
@jwt_required()
def create_project():
    data = request.get_json()
    # ... validate data with Pydantic ...
    user_id = get_jwt_identity()
    # ... database operations ...
    return jsonify({"message": "Project created"}), 201
```

Then in the React frontend, we'd use `fetch` or `axios` to call this endpoint:

```typescript
// Traditional client-side fetch
const handleSubmit = async (data) => {
  const response = await fetch('/api/project', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
    body: JSON.stringify(data),
  });
  // ... handle response and UI state ...
};
```

This "Client-Server" pattern is clear and decoupled, but also cumbersome. You need to manage API routes, HTTP methods, serialization, deserialization, CORS, authentication headers.

Next.js 14+ brings Server Actions that completely change this. It allows you to define backend logic (mutations) directly and call them from client components, without manually creating and managing API routes. This is a built-in, safer RPC (Remote Procedure Call) paradigm.

## 6.1. What Are Server Actions (vs. Django/Flask API)

A Server Action is essentially an async function that executes securely on the server, marked by adding a `"use server";` directive at the top of the function.

It can be defined in two places:

1. **Inside a Component ("Inlined"):** Directly defined in a `"use client"` client component, typically for simple, tightly-bound operations to that component.
2. **Separate File ("Server Module"):** Defined in a `.ts` file (like in our project's `src/actions/` directory), marking the entire file top with `"use server";`. This is the **best practice for SaaS projects** because it maintains clear separation and reusability of logic.

**Mindset Shift: From API to Function Call**

| Traditional Python (Flask/Django)                                   | Next.js (Server Actions)                                       |
| ---------------------------------------------------------- | -------------------------------------------------------------- |
| 1. Define an API endpoint in `views.py` or `routes.py` (`@app.route`). | 1. Define an `async function` in `src/actions/my-action.ts`.        |
| 2. In the function, parse data from `request.json` or `request.form`.           | 2. Function directly receives `formData` (for `<form>`) or regular parameters.                      |
| 3. Validate data with Pydantic or DRF Serializer.                      | 3. Validate data with Zod (see 6.2).                                         |
| 4. On the frontend, use `fetch` to initiate `POST` request to `/api/my-endpoint`.        | 4. On the frontend, `import { myAction }` and **directly call** `await myAction(data)`. |
| 5. Next.js automatically handles `fetch` wrapping, serialization, and server calls.                      | 5. For developers, this is like calling a local async function.                                      |

This approach greatly simplifies C/U/D (Create, Update, Delete) operations. Next.js abstracts away HTTP layer complexity, letting you focus more on business logic.

## 6.2. Best Practice: next-safe-action and Zod Validation

While Server Actions are powerful, their raw form is quite rough in error handling and input validation. You need to manually manage `try...catch`, and data returned to the client has no unified structure.

This is like not using Pydantic or WTForms in Flask views, but manually handling `request.form` dictionaries - unacceptable in enterprise-level SaaS.

**Enter** **`next-safe-action`****.**

`next-safe-action` is a lightweight library that provides Server Actions with:

1. **Zod Validation:** Seamless integration with Zod (discussed in Chapter 2, it's the Pydantic of the JS/TS world).
2. **Type-safe Return Values:** Returns a unified object like `{ data, validationError, serverError }`.
3. **Elegant Error Handling:** Automatically captures Zod validation errors and server runtime errors.
4. **Optimistic UI:** Easy-to-integrate `useAction` hooks for handling loading states and optimistic updates.

**Real Code Structure (Concept):**

Imagine `src/actions/project.ts` in our real project:

```typescript
// src/actions/project.ts
"use server";

import { z } from "zod";
import { createSafeActionClient } from "next-safe-action";
import { db } from "@/db"; // Our Drizzle instance
import { auth } from "@/auth"; // Our Better Auth instance

// 1. Define Zod schema (our "Pydantic" / "DRF Serializer")
export const createProjectSchema = z.object({
  name: z.string().min(3, "Project name must be at least 3 characters"),
});

// 2. Create a "safe action" client
// We can inject context, like checking if user is authenticated
const action = createSafeActionClient({
  async middleware() {
    const session = await auth(); // Check authentication
    if (!session?.user?.id) {
      throw new Error("Unauthorized: Please log in first");
    }
    return { userId: session.user.id };
  },
});

// 3. Define our Action
export const createProject = action(
  createProjectSchema, // Pass schema for validation
  async ({ name }, { userId }) => { // Receive validated "name" and "userId" from middleware

    // 4. Execute business logic (Drizzle DB operations)
    try {
      const newProject = await db.insert(projectsTable).values({
        name,
        ownerId: userId,
      }).returning();

      return { success: true, project: newProject[0] };

    } catch (error) {
      console.error(error);
      return { serverError: "Failed to create project, please try again later." };
    }
  }
);
```

**Calling from Client Component:**

```typescript
// src/components/create-project-form.tsx
"use client";

import { useAction } from "next-safe-action/hook";
import { createProject, createProjectSchema } from "@/actions/project";

export function CreateProjectForm() {
  // 5. Use useAction hook
  const { execute, result, validationErrors, serverError, status } =
    useAction(createProject);

  const onSubmit = (data: z.infer<typeof createProjectSchema>) => {
    execute(data); // Execute directly
  };

  // ... form (can use react-hook-form) ...

  {/* 6. Elegantly handle states */}
  {status === "executing" && <p>Creating...</p>}
  {serverError && <p className="text-red-500">{serverError}</p>}
  {validationErrors?.name && <p>{validationErrors.name[0]}</p>}
  {result?.data?.success && <p>Project "{result.data.project.name}" created successfully!</p>}
}
```

This pattern combines the robustness of Python backends (Pydantic validation) with the convenience of a full-stack framework.

## 6.3. [Skill Practice]: Server-Side Redirect After Server Action Execution

This is one of the most common scenarios in SaaS applications: user submits a form (e.g., creating a new project), and on success, you need to navigate them to the new project's detail page.

In Flask/Django, we'd `return redirect(url_for('project_detail', id=...))` at the end of the view function.

In Server Actions, we use the `redirect` function imported from `next/navigation`. This is a server-side API that sends an HTTP 30x redirect directive to the browser.

**Real Skill:** **Core of** **`nextjs-server-navigation/SKILL.md`** **

The key point of this Skill is understanding how `redirect()` works in Server Actions.

```typescript
// src/actions/project.ts (continued)
"use server";

import { redirect } from "next/navigation"; // Import server-side redirect
import { revalidatePath } from "next/cache"; // Import cache refresh utility
// ... other imports ...

export const createProject = action(
  createProjectSchema,
  async ({ name }, { userId }) => {

    let newProjectId: string;

    try {
      const newProject = await db.insert(projectsTable).values({
        name,
        ownerId: userId,
      }).returning({ id: projectsTable.id });

      newProjectId = newProject[0].id;

    } catch (error) {
      return { serverError: "Failed to create project" };
    }

    // After successful creation

    // 1. [Important] Refresh cache
    // Tell Next.js that '/dashboard' page data is stale and needs re-fetch on next visit
    revalidatePath("/dashboard");

    // 2. [Important] Execute server-side redirect
    // This must be called outside the try...catch block because it throws a special exception
    redirect(`/project/${newProjectId}`);

    // Note: Code after redirect() won't execute
  }
);
```

**Key Points:**

1. **`redirect()`** **(from** **`next/navigation`****):** Can only be used in Server Components or Server Actions. It terminates current function execution and initiates a redirect.
2. **`revalidatePath()`:** This is core to Next.js data caching (Chapter 5). After executing a "mutation", we must manually "invalidate the cache", otherwise when users are redirected back to the list page, they might still see old data.
3. **`useRouter`** **vs** **`redirect`:** Client components use `useRouter().push('/path')` for navigation. Server Actions use `redirect('/path')`. `redirect` is more powerful because it happens on the server.

## 6.4. [Code Analysis]: Analyzing `src/actions/` Directory in Real Project

Theory covered, now let's dive into the `src/actions/` directory in our real project. This directory is the "brain" of our SaaS application, replacing the massive collection of `api/` routes in traditional Python backends.

Opening this directory, you won't see route definitions, but **domain-divided** TS files, each marked with `"use server";` at the top.

Our SaaS template project structure might look like:

```plain text
src/actions/
├── auth.actions.ts       # Handle login, registration, logout (interact with Better Auth)
├── payment.actions.ts    # Handle Stripe payments, create checkout sessions
├── credits.actions.ts    # Handle user AI credits (credits) increment/decrement
├── project.actions.ts    # (like above example) Handle project C/U/D
├── user.actions.ts       # Handle user profile updates, API key generation
└── index.ts              # (Optional) Export all actions for easier management
```

**Analyzing** **`payment.actions.ts`** **(Concept):**

Let's walk through what `payment.actions.ts` might contain, connecting Stripe (payment) and Drizzle (database).

```typescript
// src/actions/payment.actions.ts
"use server";

import { z } from "zod";
import { createSafeActionClient } from "next-safe-action";
import { db } from "@/db";
import { auth } from "@/auth";
import { stripe } from "@/payment/stripe-server"; // Our Stripe server-side instance
import { usersTable } from "@/db/schema";
import { eq } from "drizzle-orm";
import { absoluteUrl } from "@/lib/utils";

// 1. Define Schema
const createCheckoutSchema = z.object({
  planId: z.string(), // e.g., "pro_plan_monthly"
});

// 2. Define Action (also requires authentication)
const action = createSafeActionClient({ /* ...auth middleware... */ });

export const createCheckoutSession = action(
  createCheckoutSchema,
  async ({ planId }, { userId }) => {

    // 3. Get user info from Drizzle (like Stripe Customer ID)
    const user = await db.query.usersTable.findFirst({
      where: eq(usersTable.id, userId),
    });

    if (!user) return { serverError: "User does not exist" };

    const stripeCustomerId = user.stripeCustomerId || await createStripeCustomer(user);

    const returnUrl = absoluteUrl("/dashboard/billing");

    // 4. Call Stripe API to create session
    try {
      const session = await stripe.checkout.sessions.create({
        payment_method_types: ["card"],
        mode: "subscription",
        customer: stripeCustomerId,
        line_items: [{ price: process.env[planId], quantity: 1 }],
        success_url: returnUrl,
        cancel_url: returnUrl,
      });

      if (!session.url) {
        return { serverError: "Unable to create payment session" };
      }

      // 5. Return Stripe Checkout URL
      // Client receives this URL and redirects to Stripe payment page
      return { success: true, url: session.url };

    } catch (error) {
      console.error(error);
      return { serverError: "Stripe communication failed" };
    }
  }
);
```

### Chapter Summary: The Mindset Leap

Through this chapter, we've completed the core mindset shift from "API endpoints" to "Server Actions".

For Python developers, the `src/actions/` directory is your collection of `views.py` / `api_views.py`, but it's more powerful:

1. **No Routes:** No more need for `urls.py` or `@app.route`.
2. **Type Safety:** `next-safe-action` + `Zod` provide smoother end-to-end type safety than DRF Serializer + Pydantic.
3. **Seamless Integration:** Can directly call databases (`Drizzle`), authentication (`Better Auth`), and third-party services (`Stripe`) in Actions.
4. **UI Synergy:** Action design (like `useAction` hooks) makes it perfectly integrate with React client component state management (`loading`, `error`).

This is not just less code, but a huge improvement in developer experience. We now have type-safe, validated backend mutations tightly integrated with UI.

In the next part, we'll dive deep into the data and state layers of full-stack architecture - how Drizzle ORM replaces SQLAlchemy, and how Zustand manages our global state on the client.

